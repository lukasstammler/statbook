geom_point(color = COL[1], size = 3, alpha = .7) +
geom_smooth(method = "lm", se = FALSE, color = "darkgrey") +
#geom_point(aes(y = predicted), color = COL[4], size = 2) +
geom_point(aes(y = y_hat_33, x = 33), color = COL[2], size = 5) +
geom_segment(aes(x = 33, xend = 33, y = 25.5, yend = y_hat_33), color = COL[2]) +
geom_segment(aes(x = 33, xend = 26, y = y_hat_33, yend = y_hat_33), color = COL[2], arrow = arrow()) +
geom_text(aes(x = 33, y = 25, label = "33"), color = COL[2], size = 5) +
theme_bw()
# load dataset
# source: https://static-content.springer.com/esm/art%3A10.1038%2F431525a/MediaObjects/41586_2004_BF431525a_MOESM1_ESM.doc
# https://www.nature.com/articles/431525a#MOESM1
sprint100m <- read_csv("./data/06_sprint100.csv")
# calculate multiple regression model
model_sprint100m <- lm(win_sec ~ year + sex, data = sprint100m)
# summary(model_sprint100m)
# calculate separate models for sex
sprint_m <- sprint100m %>% filter(sex == "m")
sprint_f <- sprint100m %>% filter(sex == "f")
mod_m <- lm(win_sec ~ year, data = sprint_m)
mod_f <- lm(win_sec ~ year, data = sprint_f)
# coef(mod_m)
# coef(mod_f)
annotate_mod_m <- paste("y =", round(coef(mod_m)[1], 2), round(coef(mod_m)[2], 2), "x")
annotate_mod_f <- paste("y =", round(coef(mod_f)[1], 2), round(coef(mod_f)[2], 2), "x")
# plot data, split by sex
ggplot(sprint100m, aes(x = year, y = win_sec)) +
geom_point(aes(color = sex)) +
geom_smooth(aes(color = sex), method = "lm", se = FALSE) +
geom_text(x = 1920, y = 10.2, label = annotate_mod_m, color = ggblue) +
geom_text(x = 1980, y = 11.5, label = annotate_mod_f, color = ggred) +
ylab("sec") +
xlab("Jahr") +
ggtitle("Olympische Zeit für 100m-Sprint (1900 bis 2004)") +
theme_bw()
# load dataset
# source: https://static-content.springer.com/esm/art%3A10.1038%2F431525a/MediaObjects/41586_2004_BF431525a_MOESM1_ESM.doc
# https://www.nature.com/articles/431525a#MOESM1
sprint100m <- read_csv("./data/06_sprint100.csv")
# calculate multiple regression model
model_sprint100m <- lm(win_sec ~ year + sex, data = sprint100m)
# summary(model_sprint100m)
# calculate separate models for sex
sprint_m <- sprint100m %>% filter(sex == "m")
sprint_f <- sprint100m %>% filter(sex == "f")
mod_m <- lm(win_sec ~ year, data = sprint_m)
mod_f <- lm(win_sec ~ year, data = sprint_f)
# coef(mod_m)
# coef(mod_f)
annotate_mod_m <- paste("y =", round(coef(mod_m)[1], 2), round(coef(mod_m)[2], 2), "x")
annotate_mod_f <- paste("y =", round(coef(mod_f)[1], 2), round(coef(mod_f)[2], 2), "x")
# plot data, split by sex
ggplot(sprint100m, aes(x = year, y = win_sec)) +
geom_point(aes(color = sex)) +
geom_smooth(aes(color = sex), method = "lm", se = FALSE) +
geom_text(x = 1920, y = 10.2, label = annotate_mod_m, color = ggblue) +
geom_text(x = 1980, y = 11.5, label = annotate_mod_f, color = ggred) +
ylab("sec") +
xlab("Jahr") +
ggtitle("Olympische Zeit für 100m-Sprint (1900 bis 2004)") +
theme_bw()
write_csv(sprint_extrapol, file = "./data/06_sprint100_predict.csv")
new_years <- tibble(year = seq(2004, 2200, by = 4))
pred_m <- predict(mod_m, new_years)
pred_f <- predict(mod_f, new_years)
pred_sprint <- tibble(year = c(new_years$year, new_years$year),
win_sec = c(pred_m, pred_f),
sex = c(rep("m", 50), rep("f", 50)))
sprint_extrapol <- bind_rows(sprint100m, pred_sprint)
write_csv(sprint_extrapol, file = "./data/06_sprint100_predict.csv")
set.seed(6825)
d1 <- tibble(
x = seq(0, 20, by = 1) + rnorm(mean = 5, sd = 3, n = 21),
y = 5 + 0.3 * x + rnorm(mean = 3, sd = 3, n = 21)
)
library(ggpmisc)
my.formula <- y ~ x
p1 <- ggplot(d1, aes(x = x, y = y)) +
geom_point(color = COL[1], alpha = .7, size = 3) +
geom_smooth(method = "lm", se = FALSE, color = "darkgrey", fomula = my.formula) +
stat_poly_eq(fomula = my.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
theme_minimal()+
xlab("(a)")
d2 <- tibble(
x = seq(0, 20, by = 1) + rnorm(mean = 5, sd = 3, n = 21),
y = 5 + 0.3 * x + rnorm(mean = 1.5, sd = 1, n = 21)
)
p2 <- ggplot(d2, aes(x = x, y = y)) +
geom_point(color = COL[1], alpha = .7, size = 3) +
geom_smooth(method = "lm", se = FALSE, color = "darkgrey", fomula = my.formula) +
stat_poly_eq(fomula = my.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE)+
theme_minimal() +
xlab("(b)")
d3 <- tibble(
x = seq(0, 20, by = 1) + rnorm(mean = 5, sd = 3, n = 21),
y = 5 + 0.3 * x + rnorm(mean = .5, sd = .2, n = 21)
)
p3 <- ggplot(d3, aes(x = x, y = y)) +
geom_point(color = COL[1], alpha = .7, size = 3) +
geom_smooth(method = "lm", se = FALSE, color = "darkgrey", fomula = my.formula) +
stat_poly_eq(fomula = my.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE)+
theme_minimal()+
xlab("(c)")
(p1 | p2 | p3)
heterosc <- read_csv("./data/06_heteroscedasticity.csv")
# ggplot(heterosc, aes(x = Population, y = Accidents)) +
#   geom_point(color = COL[1], size = 3, alpha = .7) +
#   geom_smooth(method = "lm", se = FALSE)
mod_heterosc <- lm(Accidents ~ Population, data = heterosc)
library(broom)
mod_heterosc_aug <- augment(mod_heterosc)
resplot4 <- ggplot(mod_heterosc_aug, aes(x = .fitted, y = .std.resid)) +
geom_point(color = COL[1], size = 3, alpha = .7) +
geom_hline(yintercept = 0, color = "red") +
theme_minimal() +
xlab("(d)")
# ----------------------------------------------------
# from modern statistics with R, p 304
exdata1 <- data.frame(
x = c(2.99, 5.01, 8.84, 6.18, 8.57, 8.23, 8.48, 0.04, 6.80,
7.62, 7.94, 6.30, 4.21, 3.61, 7.08, 3.50, 9.05, 1.06,
0.65, 8.66, 0.08, 1.48, 2.96, 2.54, 4.45),
y = c(5.25, -0.80, 4.38, -0.75, 9.93, 13.79, 19.75, 24.65,
6.84, 11.95, 12.24, 7.97, -1.20, -1.76, 10.36, 1.17,
15.41, 15.83, 18.78, 12.75, 24.17, 12.49, 4.58, 6.76,
-2.92))
exdata2 <- data.frame(
x = c(5.70, 8.03, 8.86, 0.82, 1.23, 2.96, 0.13, 8.53, 8.18,
6.88, 4.02, 9.11, 0.19, 6.91, 0.34, 4.19, 0.25, 9.72,
9.83, 6.77, 4.40, 4.70, 6.03, 5.87, 7.49),
y = c(21.66, 26.23, 19.82, 2.46, 2.83, 8.86, 0.25, 16.08,
17.67, 24.86, 8.19, 28.45, 0.52, 19.88, 0.71, 12.19,
0.64, 25.29, 26.72, 18.06, 10.70, 8.27, 15.49, 15.58,
19.17))
mod_exdata1 <- lm(y ~  x, data = exdata1)
mod_exdata2 <- lm(y ~  x, data = exdata2)
mod_exdata1_aug <- augment(mod_exdata1)
mod_exdata2_aug <- augment(mod_exdata2)
resplot1 <- ggplot(mod_exdata1_aug, aes(x = .fitted, y = .std.resid)) +
geom_point(color = COL[1], size = 3, alpha = .7) +
geom_hline(yintercept = 0, color = "red") +
theme_minimal() +
xlab("(a)")
resplot2 <- ggplot(mod_exdata2_aug, aes(x = .fitted, y = .std.resid)) +
geom_point(color = COL[1], size = 3, alpha = .7) +
geom_hline(yintercept = 0, color = "red") +
theme_minimal()+
xlab("(b)")
# ---
# http://www.sthda.com/english/articles/39-regression-model-diagnostics/161-linear-regression-assumptions-and-diagnostics-in-r-essentials/
set.seed(5)
N  = 500
b0 = 3
b1 = 0.4
s2 = 5
g1 = 1.5
g2 = 0.015
x        = runif(N, min=0, max=100)
y_homo   = b0 + b1*x + rnorm(N, mean=0, sd=sqrt(s2            ))
y_hetero = b0 + b1*x + rnorm(N, mean=0, sd=sqrt(exp(g1 + g2*x)))
hh <- tibble(
x = x,
y_homo = y_homo,
y_hetero = y_hetero
)
mod.homo   = lm(y_homo~x)
mod.hetero = lm(y_hetero~x)
mod.homo.aug <- augment(mod.homo)
resplot3 <- ggplot(mod.homo.aug, aes(x = .fitted, y = .std.resid)) +
geom_point(color = COL[1], size = 3, alpha = .7) +
geom_hline(yintercept = 0, color = "red") +
theme_minimal()+
xlab("(c)")
(resplot1 | resplot2)/
(resplot3 | resplot4)
rm(list = ls())
knitr::opts_chunk$set(echo = FALSE,
warning = FALSE,
message = FALSE,
fig.align = "center")
library(openintro)
library(tidyverse)
library(knitr)
library(patchwork)
library(kableExtra)
ggred <- "#F8766D"
ggblue <- "#00BFC4"
ggreen <- "#7CAE00"
ggviolet <- "#C77CFF"
data(COL)
library(scales)
show_col(COL[1:20])
#openintro_palettes # Hex for openintro COLs
# Probleme beim rendern: https://stackoverflow.com/questions/66305776/got-knit-issue-with-r, solution:
# tinytex::tlmgr_install("pdfcrop")
# install ghostscript https://www.ghostscript.com/download/gsdnld.html
# Sys.setenv(R_GSCMD="C:/Program Files/gs/gs9.54.0/bin/gswin64.exe")
phy <- read_csv("./data/02_phy.csv", show_col_types = FALSE)
head(phy, 5) %>%
kable(caption = "Daten der ersten 5 Studierenden im Datensatz phy.csv (n = 228)") %>%
kable_classic(full_width = FALSE)
# https://www.bfs.admin.ch/bfs/de/home/statistiken/arbeit-erwerb/loehne-erwerbseinkommen-arbeitskosten/lohnniveau-schweiz/verteilung-nettoloehne.html
income <- read_csv("./data/02_income_ch_f_2018.csv")
# für jedes Lohnband gemäss Prozentangaben Daten erstellen
code <- income$code
prozent <- income$prozent
income <- vector()
for (i in 1:21){
inc <- code[i]
mal <- prozent[i] * 10
x <- rep(inc, times = mal)
income <- c(income, x)
}
einkommen <- tibble(Einkommen = income)
# Mittelwert und Median berechnen
sum <- einkommen %>%
summarise(
M = mean(Einkommen),
Median = median(Einkommen)
)
sum <- round(sum, 1)
# Histogramm erstellen
ggplot(einkommen, aes(x = Einkommen)) +
geom_histogram(fill = COL[1], color = "white", binwidth = 1) +
xlab("CHF (in Tausend)") +
ylab("Häufigkeit") +
geom_vline(xintercept = sum$M, color = COL[4], lwd = 1) +
geom_vline(xintercept = sum$Median, color = COL[2], lwd = 1) +
ggtitle("Monatliches Einkommen Frauen CH, 2018",
subtitle = paste("Mittelwert (rot) = CHF", sum$M * 1000, ", Median (grün) = CHF", sum$Median * 1000))
phy <- read_csv("./data/02_phy_w.csv", show_col_types = FALSE)
# phy_w <- phy %>%
#   filter(Geschlecht == "w")
# write_csv(phy_w, file = "./data/phy_w.csv")
p1 <- ggplot(phy_w, aes(x = Groesse)) +
geom_histogram(color = "white", fill = COL[1], binwidth = 1) +
xlab("(A) Grösse (cm)") +
ylab("Anzahl") +
theme_bw()
p2 <- ggplot(phy_w, aes(x = Groesse)) +
geom_histogram(color = "white", fill = COL[1], binwidth = 2) +
xlab("(B) Grösse (cm)") +
ylab("Anzahl") +
theme_bw()
p3 <- ggplot(phy_w, aes(x = Groesse)) +
geom_histogram(color = "white", fill = COL[1], binwidth = 5) +
xlab("(C) Grösse (cm)") +
ylab("Anzahl") +
theme_bw()
p4 <- ggplot(phy_w, aes(x = Groesse)) +
geom_histogram(color = "white", fill = COL[1], binwidth = 10) +
xlab("(D) Grösse (cm)") +
ylab("Anzahl") +
theme_bw()
(p1 | p2)/
(p3 | p4)
phy_w <- read_csv("./data/02_phy_w.csv", show_col_types = FALSE)
# phy_w <- phy %>%
#   filter(Geschlecht == "w")
# write_csv(phy_w, file = "./data/phy_w.csv")
p1 <- ggplot(phy_w, aes(x = Groesse)) +
geom_histogram(color = "white", fill = COL[1], binwidth = 1) +
xlab("(A) Grösse (cm)") +
ylab("Anzahl") +
theme_bw()
p2 <- ggplot(phy_w, aes(x = Groesse)) +
geom_histogram(color = "white", fill = COL[1], binwidth = 2) +
xlab("(B) Grösse (cm)") +
ylab("Anzahl") +
theme_bw()
p3 <- ggplot(phy_w, aes(x = Groesse)) +
geom_histogram(color = "white", fill = COL[1], binwidth = 5) +
xlab("(C) Grösse (cm)") +
ylab("Anzahl") +
theme_bw()
p4 <- ggplot(phy_w, aes(x = Groesse)) +
geom_histogram(color = "white", fill = COL[1], binwidth = 10) +
xlab("(D) Grösse (cm)") +
ylab("Anzahl") +
theme_bw()
(p1 | p2)/
(p3 | p4)
set.seed(2)
data <- tibble(
set = c(rep("SP1", 20), rep("SP2", 20)),
x = c(rnorm(20, mean = 0, sd = 0.2), rnorm(20, mean = 0, sd = 1)),
y = c(rep(1, 20), rep(2, 20))
)
ggplot(data, aes(x = x, y = y, color = set)) +
geom_point(size = 3, alpha = .6) +
theme_minimal() +
ylim(0, 3) +
theme(legend.position = "none",
panel.grid = element_blank(),
axis.title = element_blank(),
axis.ticks.y = element_blank(),
axis.text.y = element_blank()) +
geom_vline(xintercept = 0)
data %>%
group_by(set) %>%
summarise(
M = mean(x),
s = sd(x)
)
publish_book(render = "local")
bookdown::publish_book(render = "local")
install.packages(c("backports", "gld"))
rsconnect::servers()
rm(list = ls())
knitr::opts_chunk$set(echo = FALSE,
warning = FALSE,
message = FALSE,
fig.align = "center",
fig.dim = c(5,4))
library(openintro)
library(tidyverse)
library(knitr)
library(patchwork)
library(Hmisc)       # for errorbars in ggplot
library(kableExtra)
library(graphics)
ggred <- "#F8766D"
ggblue <- "#00BFC4"
ggreen <- "#7CAE00"
ggviolet <- "#C77CFF"
library(scales)
show_col(COL[1:20])
gr1 <- tibble(
gruppe = rep("Gruppe_1", times = 17),
eltern = rep(0, times = 17),
kind = rep(0, times = 17)
)
gr2 <- tibble(
gruppe = rep("Gruppe_2", times = 5),
eltern = rep(1, times = 5),
kind = rep(0, times = 5)
)
gr3 <- tibble(
gruppe = rep("Gruppe_3", times = 7),
eltern = rep(0, times = 7),
kind = rep(1, times = 7)
)
gr4 <- tibble(
gruppe = rep("Gruppe_4", times = 9),
eltern = rep(1, times = 9),
kind = rep(1, times = 9)
)
parsifal <- bind_rows(gr1, gr2, gr3, gr4)
# write_csv(parsifal, file = "C:/Users/balbu/switchdrive/R/Github/STAT/Datasets/parsifal.csv")
jmv::contTables(
formula = ~kind:eltern,
data = parsifal,
exp = FALSE,
pcTot = TRUE,
chiSq = FALSE,
)
jmv::contTables(
formula = ~kind:eltern,
data = parsifal,
exp = TRUE,
chiSq = FALSE,
)
# descr::CrossTable(parsifal$kind, parsifal$eltern, prop.r = FALSE, prop.c = FALSE, prop.t = FALSE,
#            prop.chisq = FALSE, expected = TRUE)
100000/12
data("student_sleep")
# write_csv(student_sleep, file = "./data/04_student_sleep.csv")
student_sleep %>%
summarise(
n = n(),
M = mean(hours),
s = sd(hours),
median = median(hours)
) %>%
kbl(digits = 2, caption = "Kennzahlen zur Schlafdauer (h)") %>%
kable_classic(full_width = FALSE)
rm(list = ls())
knitr::opts_chunk$set(echo = FALSE,
warning = FALSE,
message = FALSE,
fig.align = "center",
fig.dim = c(5,4))
library(openintro)
library(tidyverse)
library(knitr)
library(patchwork)
library(Hmisc)       # for errorbars in ggplot
library(kableExtra)
library(graphics)
ggred <- "#F8766D"
ggblue <- "#00BFC4"
ggreen <- "#7CAE00"
ggviolet <- "#C77CFF"
library(scales)
show_col(COL[1:20])
data("student_sleep")
# write_csv(student_sleep, file = "./data/04_student_sleep.csv")
student_sleep %>%
summarise(
n = n(),
M = mean(hours),
s = sd(hours),
median = median(hours)
) %>%
kbl(digits = 2, caption = "Kennzahlen zur Schlafdauer (h)") %>%
kable_classic(full_width = FALSE)
### R-Code
n <- 110     # Stichprobenumfang
m <- 7.42    # Mittelwert der Stichprobe
s <- 1.75    # Standardabweichung des Mittelwerts der Stichprobe
SE <- s/sqrt(n)  # Berechnung des Standardfehlers
#SE         # not run: Ausgabe des Standardfehlers
CI95 <- round(m + c(-1, 1) * 1.96 * SE, 2)  # 95%-Vertrauensintervall berechnen
#CI95       # not run: Ausgabe des 95% Vertrauensintervalls
plot_ci_sleep <- ggplot(student_sleep, aes(x = 0, y = hours)) +
stat_summary(fun.y = mean, geom = "point", color = COL[4], size = 2) +
stat_summary(fun.data = mean_cl_normal, geom = "errorbar", width = 0) +
geom_hline(yintercept = 7, col = COL[4], linetype = "dashed", size = 1) +
ylab("Stunden")+
xlab("") +
coord_flip()
plot_ci_sleep +
theme(axis.ticks.y = element_blank(),
axis.text.y = element_blank())
CI95       # not run: Ausgabe des 95% Vertrauensintervalls
normTail(m = 0, s = 1, U = 1.64, col = COL[1], axes = 0)
yMax <- .4
label1 = expression('7.42 = '*bar(x))
label2 = expression('H0: 7 = '*mu)
axis(1, at = c(0, 2.47), labels = c(label2, label1))
axis(1, at = c(-4, 4))
points(x = 2.47, y = c(0), pch = 21, cex = 2.5, col = "black", bg = "#F05133", add = TRUE)
text(x = c(0, 2.5), y = c(0.1, 0.1), labels = c("95%", "5%"))
yMax = .4
arrows(2.4, yMax / 5, 2.2, yMax / 10,
length = 0.1, lwd = 2, col = COL[1])
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
rot <- c(rep("alive", 215), rep("dead", 24))
gold <- c(rep("alive", 46), rep("dead", 9))
blue <- c(rep("alive", 129), rep("dead", 7))
rot <- c(rep("alive", 215), rep("dead", 24))
gold <- c(rep("alive", 46), rep("dead", 9))
blue <- c(rep("alive", 129), rep("dead", 7))
startrek <- tibble(
color = c(length(rot), length(gold), length(blue))
status = c(rot, gold, blue)
)
rot <- c(rep("alive", 215), rep("dead", 24))
gold <- c(rep("alive", 46), rep("dead", 9))
blue <- c(rep("alive", 129), rep("dead", 7))
startrek <- tibble(
color = c(length(rot), length(gold), length(blue)),
status = c(rot, gold, blue)
)
rot <- c(rep("alive", 215), rep("dead", 24))
gold <- c(rep("alive", 46), rep("dead", 9))
blue <- c(rep("alive", 129), rep("dead", 7))
startrek <- tibble(
color = c(rep("rot", length(rot)), rep("gold", length(gold)), rep("blue", length(blue)),
status = c(rot, gold, blue)
)
rot <- c(rep("alive", 215), rep("dead", 24))
gold <- c(rep("alive", 46), rep("dead", 9))
blue <- c(rep("alive", 129), rep("dead", 7))
startrek <- tibble(
color = c(rep("rot", length(rot)), rep("gold", length(gold)), rep("blue", length(blue)),
status = c(rot, gold, blue)
)
startrek
rot <- c(rep("alive", 215), rep("dead", 24))
gold <- c(rep("alive", 46), rep("dead", 9))
blue <- c(rep("alive", 129), rep("dead", 7))
startrek <- tibble(
color = c(rep("rot", length(rot)), rep("gold", length(gold)), rep("blue", length(blue))),
status = c(rot, gold, blue)
)
chisq.test(startrek)
table(startrek)
chisq.test(table(startrek))
chisq.startrek <- chisq.test(table(startrek))
chisq.startrek
chisq.startrek <- chisq.test(table(startrek))
chisq.startrek
chisq.startrek$observed
chisq.startrek <- chisq.test(table(startrek))
chisq.startrek
chisq.startrek$expected
rm(list = ls())
knitr::opts_chunk$set(echo = FALSE,
warning = FALSE,
message = FALSE,
fig.align = "center",
fig.dim = c(5, 4))
library(openintro)
library(tidyverse)
library(knitr)
library(patchwork)
library(Hmisc)       # for errorbars in ggplot
library(kableExtra)
library(graphics)
ggred <- "#F8766D"
ggblue <- "#00BFC4"
ggreen <- "#7CAE00"
ggviolet <- "#C77CFF"
library(scales)
show_col(COL[1:20])

Xc2  <- cbind(Xctr[, 1], x2o)                     # bind to matrix
Y    <- Xc2 %*% diag(1 / sqrt(colSums(Xc2 ^ 2)))  # scale columns to length 1
y <- Y[, 2] + (1 / tan(theta)) * Y[, 1]     # final new vector
return(y)
}
# Case 12: A single negative outlier - same as 11 but the other way.
r <- 0.8  # LS Korrelationskoeffizient = 0.8
n <- 50   # LS n = 50
set.seed(3)
x <- rnorm(n - 1)
x <- c(sort(x), 10)
y <- c(rnorm(n - 1),-15)
y <- compute.y(x, y, r)
plot(
x,
y,
ylab = "",
xlab = "",
main = paste("(12) A single negative outlier", sep = "")
)
abline(lm(y ~ x), col = "dodgerblue3")
df12 <- data.frame(x, y)
# Regression line without outlier
group1 <- x[1:(n - 1)]
y1 <- y[1:(n - 1)]
xseg1 <- seq(
from = min(group1),
to = max(group1),
length.out = 50
)
pred1 <- predict(lm(y1 ~ group1), newdata = data.frame(group1 = xseg1))
lines(xseg1, pred1, lty = 1, col = "red")
cordata <- tibble(x, y)
cordata_noOutlier <- cordata %>%
filter(x < 10)
cor_noOutlier <- round(cor(cordata_noOutlier$x, cordata_noOutlier$y), 3)
# plot beschriften
text(x=1, y=0.5, labels="r = 0.925", col = "red")
text(x=6, y=0.5, labels="r = 0.8", col = "dodgerblue3")
# cor_noOutlier
# cor(x, y, method = "spearman")
set.seed(3)
shoe_m <- round(rnorm(500, mean = 42, sd = 2), 0)
shoe_f <- round(rnorm(500, mean = 37, sd = 2), 0)
salary_m <- rnorm(500, mean = 11000, sd = 3000)
salary_f <- rnorm(500, mean = 5000, sd = 1500)
data <- tibble(
sex = c(rep("m", times = 500), rep("f", times = 500)),
size = c(shoe_m, shoe_f),
salary = c(salary_m, salary_f)
) %>%
filter(size > 33 & size < 50)
write_csv(data, file = "./data/05_shoesize.csv")
rm(list = ls())
knitr::opts_chunk$set(echo = FALSE,
warning = FALSE,
message = FALSE,
fig.align = "center")
library(openintro)
library(tidyverse)
library(knitr)
library(patchwork)
library(Hmisc)       # for errorbars in ggplot
library(kableExtra)
library(graphics)
ggred <- "#F8766D"
ggblue <- "#00BFC4"
ggreen <- "#7CAE00"
ggviolet <- "#C77CFF"
library(scales)
show_col(COL[1:20])
# https://www.nku.edu/~statistics/Simple_Linear_Regression.htm
bookstore <- read_csv("./data/06_bookstore.csv")
bookstore %>%
kable(align = "c") %>%
kable_styling(bootstrap_options = "striped", full_width = FALSE, position = "center")
# https://www.nku.edu/~statistics/Simple_Linear_Regression.htm
bookstore <- read_csv("./data/06_bookstore.csv")
bookstore %>%
kable(align = "c", caption = "Buchhandlung") %>%
kable_styling(bootstrap_options = "striped", full_width = FALSE, position = "center")
x <- seq(-3, 2, by = .1)
y <- 2*x + 4
fkt <- tibble(x = x, y = y)
ggplot(fkt, aes(x = x, y = y)) +
geom_smooth(method = "lm", color = "red") +
geom_hline(yintercept = 0) +
geom_vline(xintercept = 0) +
scale_y_continuous(breaks = seq(-3, 8)) +
scale_x_continuous(breaks = seq(-3, 2)) +
geom_segment(aes(x = 0, xend = 1, y = 4, yend = 4), color = "steelblue", data = fkt) +
geom_segment(aes(x = 1, xend = 1, y = 4, yend = 6), color = "steelblue", data = fkt) +
geom_segment(aes(x = -3, xend = 0, y = 4, yend = 4), color = "steelblue", data = fkt, linetype = "dashed") +
theme_bw() +
geom_text(aes(x = 0.5, y = 3.5, label = "1"), color = "steelblue", size = 6) +
geom_text(aes(x = 1.2, y = 5, label = "2"), color = "steelblue", size = 6) +
geom_label(aes(x = -1, y = 3.5, label = "y = 2x + 4"), color = "red") +
geom_label(aes(x = 1.5, y = 3.5, label = "a = dy/dx = 2/1"), color = "steelblue") +
geom_label(aes(x = -.2, y = 4.5, label = "b"), color = "steelblue")
d <- openintro::elmhurst
d$gift_aid <- d$gift_aid * 1000
d$family_income <- d$family_income * 1000
g <- lm(d$gift_aid ~ d$family_income)
summary(g)
loss <- function(a, b, d) {
p <- a + b * d$family_income
sum(abs(d$gift_aid - p))
}
a      <- round(g$coef[1], 2) + seq(-500, 500, 1)
b      <- round(g$coef[2], 3) + seq(-0.01, 0.01, 0.0001)
mins   <- c(a[1], b[1])
theMin <- loss(a[1], b[1], d)
pb     <- txtProgressBar(1, length(a), style=3)
for (i in 1:length(a)) {
for (j in 1:length(b)) {
hold <- loss(a[i], b[j], d)
if (hold < theMin) {
mins <- c(a[i],b[j])
theMin <- hold
}
}
}
BuildElmhurtPlot <- function() {
plot(d$family_income, d$gift_aid,
col = COL[1, 2],
pch = 19,
xlab = 'Familieneinkommen',
ylab = '', axes=FALSE,
xlim = c(0, 280e3),
ylim = c(0, 35e3))
AxisInDollars(1, at = (0:8) * 50e3)
AxisInDollars(2, at = (0:3) * 10e3)
box()
par(las = 0)
mtext("Unterstützung durch Universität", 2, line = 3)
}
BuildElmhurtPlot()
abline(mins[1], mins[2], lty=2, lwd=2)
abline(g, lwd = 2)
y_hat_33 <- 8.93 + 0.69 * 33
ggplot(bookstore, aes(x = Studierende, y = Buecher)) +
#geom_segment(aes(xend = Studierende, yend = predicted), color = "orange", alpha = 1) +
geom_point(color = COL[1], size = 3, alpha = .7) +
geom_smooth(method = "lm", se = FALSE, color = "darkgrey") +
#geom_point(aes(y = predicted), color = COL[4], size = 2) +
geom_point(aes(y = y_hat_33, x = 33), color = COL[2], size = 5) +
geom_segment(aes(x = 33, xend = 33, y = 25.5, yend = y_hat_33), color = COL[2]) +
geom_segment(aes(x = 33, xend = 26, y = y_hat_33, yend = y_hat_33), color = COL[2], arrow = arrow()) +
geom_text(aes(x = 33, y = 25, label = "33"), color = COL[2], size = 5) +
theme_bw()
# load dataset
# source: https://static-content.springer.com/esm/art%3A10.1038%2F431525a/MediaObjects/41586_2004_BF431525a_MOESM1_ESM.doc
# https://www.nature.com/articles/431525a#MOESM1
sprint100m <- read_csv("./data/06_sprint100.csv")
# calculate multiple regression model
model_sprint100m <- lm(win_sec ~ year + sex, data = sprint100m)
# summary(model_sprint100m)
# calculate separate models for sex
sprint_m <- sprint100m %>% filter(sex == "m")
sprint_f <- sprint100m %>% filter(sex == "f")
mod_m <- lm(win_sec ~ year, data = sprint_m)
mod_f <- lm(win_sec ~ year, data = sprint_f)
# coef(mod_m)
# coef(mod_f)
annotate_mod_m <- paste("y =", round(coef(mod_m)[1], 2), round(coef(mod_m)[2], 2), "x")
annotate_mod_f <- paste("y =", round(coef(mod_f)[1], 2), round(coef(mod_f)[2], 2), "x")
# plot data, split by sex
ggplot(sprint100m, aes(x = year, y = win_sec)) +
geom_point(aes(color = sex)) +
geom_smooth(aes(color = sex), method = "lm", se = FALSE) +
geom_text(x = 1920, y = 10.2, label = annotate_mod_m, color = ggblue) +
geom_text(x = 1980, y = 11.5, label = annotate_mod_f, color = ggred) +
ylab("sec") +
xlab("Jahr") +
ggtitle("Olympische Zeit für 100m-Sprint (1900 bis 2004)") +
theme_bw()
# load dataset
# source: https://static-content.springer.com/esm/art%3A10.1038%2F431525a/MediaObjects/41586_2004_BF431525a_MOESM1_ESM.doc
# https://www.nature.com/articles/431525a#MOESM1
sprint100m <- read_csv("./data/06_sprint100.csv")
# calculate multiple regression model
model_sprint100m <- lm(win_sec ~ year + sex, data = sprint100m)
# summary(model_sprint100m)
# calculate separate models for sex
sprint_m <- sprint100m %>% filter(sex == "m")
sprint_f <- sprint100m %>% filter(sex == "f")
mod_m <- lm(win_sec ~ year, data = sprint_m)
mod_f <- lm(win_sec ~ year, data = sprint_f)
# coef(mod_m)
# coef(mod_f)
annotate_mod_m <- paste("y =", round(coef(mod_m)[1], 2), round(coef(mod_m)[2], 2), "x")
annotate_mod_f <- paste("y =", round(coef(mod_f)[1], 2), round(coef(mod_f)[2], 2), "x")
# plot data, split by sex
ggplot(sprint100m, aes(x = year, y = win_sec)) +
geom_point(aes(color = sex)) +
geom_smooth(aes(color = sex), method = "lm", se = FALSE) +
geom_text(x = 1920, y = 10.2, label = annotate_mod_m, color = ggblue) +
geom_text(x = 1980, y = 11.5, label = annotate_mod_f, color = ggred) +
ylab("sec") +
xlab("Jahr") +
ggtitle("Olympische Zeit für 100m-Sprint (1900 bis 2004)") +
theme_bw()
write_csv(sprint_extrapol, file = "./data/06_sprint100_predict.csv")
new_years <- tibble(year = seq(2004, 2200, by = 4))
pred_m <- predict(mod_m, new_years)
pred_f <- predict(mod_f, new_years)
pred_sprint <- tibble(year = c(new_years$year, new_years$year),
win_sec = c(pred_m, pred_f),
sex = c(rep("m", 50), rep("f", 50)))
sprint_extrapol <- bind_rows(sprint100m, pred_sprint)
write_csv(sprint_extrapol, file = "./data/06_sprint100_predict.csv")
set.seed(6825)
d1 <- tibble(
x = seq(0, 20, by = 1) + rnorm(mean = 5, sd = 3, n = 21),
y = 5 + 0.3 * x + rnorm(mean = 3, sd = 3, n = 21)
)
library(ggpmisc)
my.formula <- y ~ x
p1 <- ggplot(d1, aes(x = x, y = y)) +
geom_point(color = COL[1], alpha = .7, size = 3) +
geom_smooth(method = "lm", se = FALSE, color = "darkgrey", fomula = my.formula) +
stat_poly_eq(fomula = my.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE) +
theme_minimal()+
xlab("(a)")
d2 <- tibble(
x = seq(0, 20, by = 1) + rnorm(mean = 5, sd = 3, n = 21),
y = 5 + 0.3 * x + rnorm(mean = 1.5, sd = 1, n = 21)
)
p2 <- ggplot(d2, aes(x = x, y = y)) +
geom_point(color = COL[1], alpha = .7, size = 3) +
geom_smooth(method = "lm", se = FALSE, color = "darkgrey", fomula = my.formula) +
stat_poly_eq(fomula = my.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE)+
theme_minimal() +
xlab("(b)")
d3 <- tibble(
x = seq(0, 20, by = 1) + rnorm(mean = 5, sd = 3, n = 21),
y = 5 + 0.3 * x + rnorm(mean = .5, sd = .2, n = 21)
)
p3 <- ggplot(d3, aes(x = x, y = y)) +
geom_point(color = COL[1], alpha = .7, size = 3) +
geom_smooth(method = "lm", se = FALSE, color = "darkgrey", fomula = my.formula) +
stat_poly_eq(fomula = my.formula,
aes(label = paste(..eq.label.., ..rr.label.., sep = "~~~")),
parse = TRUE)+
theme_minimal()+
xlab("(c)")
(p1 | p2 | p3)
heterosc <- read_csv("./data/06_heteroscedasticity.csv")
# ggplot(heterosc, aes(x = Population, y = Accidents)) +
#   geom_point(color = COL[1], size = 3, alpha = .7) +
#   geom_smooth(method = "lm", se = FALSE)
mod_heterosc <- lm(Accidents ~ Population, data = heterosc)
library(broom)
mod_heterosc_aug <- augment(mod_heterosc)
resplot4 <- ggplot(mod_heterosc_aug, aes(x = .fitted, y = .std.resid)) +
geom_point(color = COL[1], size = 3, alpha = .7) +
geom_hline(yintercept = 0, color = "red") +
theme_minimal() +
xlab("(d)")
# ----------------------------------------------------
# from modern statistics with R, p 304
exdata1 <- data.frame(
x = c(2.99, 5.01, 8.84, 6.18, 8.57, 8.23, 8.48, 0.04, 6.80,
7.62, 7.94, 6.30, 4.21, 3.61, 7.08, 3.50, 9.05, 1.06,
0.65, 8.66, 0.08, 1.48, 2.96, 2.54, 4.45),
y = c(5.25, -0.80, 4.38, -0.75, 9.93, 13.79, 19.75, 24.65,
6.84, 11.95, 12.24, 7.97, -1.20, -1.76, 10.36, 1.17,
15.41, 15.83, 18.78, 12.75, 24.17, 12.49, 4.58, 6.76,
-2.92))
exdata2 <- data.frame(
x = c(5.70, 8.03, 8.86, 0.82, 1.23, 2.96, 0.13, 8.53, 8.18,
6.88, 4.02, 9.11, 0.19, 6.91, 0.34, 4.19, 0.25, 9.72,
9.83, 6.77, 4.40, 4.70, 6.03, 5.87, 7.49),
y = c(21.66, 26.23, 19.82, 2.46, 2.83, 8.86, 0.25, 16.08,
17.67, 24.86, 8.19, 28.45, 0.52, 19.88, 0.71, 12.19,
0.64, 25.29, 26.72, 18.06, 10.70, 8.27, 15.49, 15.58,
19.17))
mod_exdata1 <- lm(y ~  x, data = exdata1)
mod_exdata2 <- lm(y ~  x, data = exdata2)
mod_exdata1_aug <- augment(mod_exdata1)
mod_exdata2_aug <- augment(mod_exdata2)
resplot1 <- ggplot(mod_exdata1_aug, aes(x = .fitted, y = .std.resid)) +
geom_point(color = COL[1], size = 3, alpha = .7) +
geom_hline(yintercept = 0, color = "red") +
theme_minimal() +
xlab("(a)")
resplot2 <- ggplot(mod_exdata2_aug, aes(x = .fitted, y = .std.resid)) +
geom_point(color = COL[1], size = 3, alpha = .7) +
geom_hline(yintercept = 0, color = "red") +
theme_minimal()+
xlab("(b)")
# ---
# http://www.sthda.com/english/articles/39-regression-model-diagnostics/161-linear-regression-assumptions-and-diagnostics-in-r-essentials/
set.seed(5)
N  = 500
b0 = 3
b1 = 0.4
s2 = 5
g1 = 1.5
g2 = 0.015
x        = runif(N, min=0, max=100)
y_homo   = b0 + b1*x + rnorm(N, mean=0, sd=sqrt(s2            ))
y_hetero = b0 + b1*x + rnorm(N, mean=0, sd=sqrt(exp(g1 + g2*x)))
hh <- tibble(
x = x,
y_homo = y_homo,
y_hetero = y_hetero
)
mod.homo   = lm(y_homo~x)
mod.hetero = lm(y_hetero~x)
mod.homo.aug <- augment(mod.homo)
resplot3 <- ggplot(mod.homo.aug, aes(x = .fitted, y = .std.resid)) +
geom_point(color = COL[1], size = 3, alpha = .7) +
geom_hline(yintercept = 0, color = "red") +
theme_minimal()+
xlab("(c)")
(resplot1 | resplot2)/
(resplot3 | resplot4)
rm(list = ls())
knitr::opts_chunk$set(echo = FALSE,
warning = FALSE,
message = FALSE,
fig.align = "center")
library(openintro)
library(tidyverse)
library(knitr)
library(patchwork)
library(kableExtra)
ggred <- "#F8766D"
ggblue <- "#00BFC4"
ggreen <- "#7CAE00"
ggviolet <- "#C77CFF"
data(COL)
library(scales)
show_col(COL[1:20])
#openintro_palettes # Hex for openintro COLs
# Probleme beim rendern: https://stackoverflow.com/questions/66305776/got-knit-issue-with-r, solution:
# tinytex::tlmgr_install("pdfcrop")
# install ghostscript https://www.ghostscript.com/download/gsdnld.html
# Sys.setenv(R_GSCMD="C:/Program Files/gs/gs9.54.0/bin/gswin64.exe")
phy <- read_csv("./data/02_phy.csv", show_col_types = FALSE)
head(phy, 5) %>%
kable(caption = "Daten der ersten 5 Studierenden im Datensatz phy.csv (n = 228)") %>%
kable_classic(full_width = FALSE)
# https://www.bfs.admin.ch/bfs/de/home/statistiken/arbeit-erwerb/loehne-erwerbseinkommen-arbeitskosten/lohnniveau-schweiz/verteilung-nettoloehne.html
income <- read_csv("./data/02_income_ch_f_2018.csv")
# für jedes Lohnband gemäss Prozentangaben Daten erstellen
code <- income$code
prozent <- income$prozent
income <- vector()
for (i in 1:21){
inc <- code[i]
mal <- prozent[i] * 10
x <- rep(inc, times = mal)
income <- c(income, x)
}
einkommen <- tibble(Einkommen = income)
# Mittelwert und Median berechnen
sum <- einkommen %>%
summarise(
M = mean(Einkommen),
Median = median(Einkommen)
)
sum <- round(sum, 1)
# Histogramm erstellen
ggplot(einkommen, aes(x = Einkommen)) +
geom_histogram(fill = COL[1], color = "white", binwidth = 1) +
xlab("CHF (in Tausend)") +
ylab("Häufigkeit") +
geom_vline(xintercept = sum$M, color = COL[4], lwd = 1) +
geom_vline(xintercept = sum$Median, color = COL[2], lwd = 1) +
ggtitle("Monatliches Einkommen Frauen CH, 2018",
subtitle = paste("Mittelwert (rot) = CHF", sum$M * 1000, ", Median (grün) = CHF", sum$Median * 1000))
phy <- read_csv("./data/02_phy_w.csv", show_col_types = FALSE)
# phy_w <- phy %>%
#   filter(Geschlecht == "w")
# write_csv(phy_w, file = "./data/phy_w.csv")
p1 <- ggplot(phy_w, aes(x = Groesse)) +
geom_histogram(color = "white", fill = COL[1], binwidth = 1) +
xlab("(A) Grösse (cm)") +
ylab("Anzahl") +
theme_bw()
p2 <- ggplot(phy_w, aes(x = Groesse)) +
geom_histogram(color = "white", fill = COL[1], binwidth = 2) +
xlab("(B) Grösse (cm)") +
ylab("Anzahl") +
theme_bw()
p3 <- ggplot(phy_w, aes(x = Groesse)) +
geom_histogram(color = "white", fill = COL[1], binwidth = 5) +
xlab("(C) Grösse (cm)") +
ylab("Anzahl") +
theme_bw()
p4 <- ggplot(phy_w, aes(x = Groesse)) +
geom_histogram(color = "white", fill = COL[1], binwidth = 10) +
xlab("(D) Grösse (cm)") +
ylab("Anzahl") +
theme_bw()
(p1 | p2)/
(p3 | p4)
phy_w <- read_csv("./data/02_phy_w.csv", show_col_types = FALSE)
# phy_w <- phy %>%
#   filter(Geschlecht == "w")
# write_csv(phy_w, file = "./data/phy_w.csv")
p1 <- ggplot(phy_w, aes(x = Groesse)) +
geom_histogram(color = "white", fill = COL[1], binwidth = 1) +
xlab("(A) Grösse (cm)") +
ylab("Anzahl") +
theme_bw()
p2 <- ggplot(phy_w, aes(x = Groesse)) +
geom_histogram(color = "white", fill = COL[1], binwidth = 2) +
xlab("(B) Grösse (cm)") +
ylab("Anzahl") +
theme_bw()
p3 <- ggplot(phy_w, aes(x = Groesse)) +
geom_histogram(color = "white", fill = COL[1], binwidth = 5) +
xlab("(C) Grösse (cm)") +
ylab("Anzahl") +
theme_bw()
p4 <- ggplot(phy_w, aes(x = Groesse)) +
geom_histogram(color = "white", fill = COL[1], binwidth = 10) +
xlab("(D) Grösse (cm)") +
ylab("Anzahl") +
theme_bw()
(p1 | p2)/
(p3 | p4)
set.seed(2)
data <- tibble(
set = c(rep("SP1", 20), rep("SP2", 20)),
x = c(rnorm(20, mean = 0, sd = 0.2), rnorm(20, mean = 0, sd = 1)),
y = c(rep(1, 20), rep(2, 20))
)
ggplot(data, aes(x = x, y = y, color = set)) +
geom_point(size = 3, alpha = .6) +
theme_minimal() +
ylim(0, 3) +
theme(legend.position = "none",
panel.grid = element_blank(),
axis.title = element_blank(),
axis.ticks.y = element_blank(),
axis.text.y = element_blank()) +
geom_vline(xintercept = 0)
data %>%
group_by(set) %>%
summarise(
M = mean(x),
s = sd(x)
)
publish_book(render = "local")
bookdown::publish_book(render = "local")
install.packages(c("backports", "gld"))
rsconnect::servers()
rm(list = ls())
knitr::opts_chunk$set(echo = FALSE,
warning = FALSE,
message = FALSE,
fig.align = "center",
fig.dim = c(5,4))
library(openintro)
library(tidyverse)
library(knitr)
library(patchwork)
library(Hmisc)       # for errorbars in ggplot
library(kableExtra)
library(graphics)
ggred <- "#F8766D"
ggblue <- "#00BFC4"
ggreen <- "#7CAE00"
ggviolet <- "#C77CFF"
library(scales)
show_col(COL[1:20])
gr1 <- tibble(
gruppe = rep("Gruppe_1", times = 17),
eltern = rep(0, times = 17),
kind = rep(0, times = 17)
)
gr2 <- tibble(
gruppe = rep("Gruppe_2", times = 5),
eltern = rep(1, times = 5),
kind = rep(0, times = 5)
)
gr3 <- tibble(
gruppe = rep("Gruppe_3", times = 7),
eltern = rep(0, times = 7),
kind = rep(1, times = 7)
)
gr4 <- tibble(
gruppe = rep("Gruppe_4", times = 9),
eltern = rep(1, times = 9),
kind = rep(1, times = 9)
)
parsifal <- bind_rows(gr1, gr2, gr3, gr4)
# write_csv(parsifal, file = "C:/Users/balbu/switchdrive/R/Github/STAT/Datasets/parsifal.csv")
jmv::contTables(
formula = ~kind:eltern,
data = parsifal,
exp = FALSE,
pcTot = TRUE,
chiSq = FALSE,
)
jmv::contTables(
formula = ~kind:eltern,
data = parsifal,
exp = TRUE,
chiSq = FALSE,
)
# descr::CrossTable(parsifal$kind, parsifal$eltern, prop.r = FALSE, prop.c = FALSE, prop.t = FALSE,
#            prop.chisq = FALSE, expected = TRUE)
100000/12
